#!/usr/bin/python
"""
Script for ~iNtErAcTiVe~ realtime multicopter simulation.

"""
from __future__ import division
import numpy as np; npl = np.linalg

from mayavi import mlab
from tvtk.tools import visual

from multicopter import motion
from multicopter.bois import hexboi
from multicopter.controller import Controller

# Send pointlessly spammed mayavi warnings to the shadow realm
import os, vtk
if os.path.exists("/dev/null"): shadow_realm = "/dev/null"
else: shadow_realm = "c:\\nul"
mlab_warning_output = vtk.vtkFileOutputWindow()
mlab_warning_output.SetFileName(shadow_realm)
vtk.vtkOutputWindow().SetInstance(mlab_warning_output)

# Configure controller (temporarily with exact model knowledge)
kp = [0, 0, 0, 0.5, 0.5, 0.5]
kd = [0, 0, 10, 0.1, 0.1, 0.1]
controller = Controller(hexboi, kp, kd)

# Scheduled external disturbance wrench
wind = lambda t: None

# Initial condition
state = motion.State(motion.Pose([10, 10, 10], [0, 0, 0, 1]),
                     motion.Twist([0, 0, 0], [0, 0, 0]),
                     0.0)

# Main display set-up
fig = mlab.figure(size=(500, 500), bgcolor=(0.1, 0.1, 0.1))
visual.set_viewer(fig)

# Environment display set-up
building_grid = (4, 4)
building_size = (3, 3, 4)
building_alley = 3
n_buildings = np.product(building_grid)
building_colors = map(tuple, np.array((np.linspace(0.0, 0.0, n_buildings),
                                       np.linspace(0.8, 0.3, n_buildings),
                                       np.linspace(0.3, 0.8, n_buildings))).T)
building_centers = np.zeros((n_buildings, 2))
for i, x in enumerate(np.linspace(0, (building_grid[0]-1)*(building_size[0] + building_alley), building_grid[0])):
    for j, y in enumerate(np.linspace(0, (building_grid[1]-1)*(building_size[1] + building_alley), building_grid[1])):
        idx = building_grid[1]*i + j
        building_centers[idx] = (x, y)
        visual.box(x=x, y=y, z=building_size[2]/2, size=building_size, color=building_colors[idx])
ground_xx, ground_yy = map(np.transpose, np.meshgrid(np.linspace(np.min(building_centers[:, 0]-5), np.max(building_centers[:, 0]+5), 5),
                                         np.linspace(np.min(building_centers[:, 1]-5), np.max(building_centers[:, 1]+5), 5)))
mlab.surf(ground_xx, ground_yy, np.zeros_like(ground_xx), color=(0, 0.2, 0.2), warp_scale=1)

# Multicopter display set-up
copter_forward = np.transpose([(0, 0, 0), (1.1*npl.norm(hexboi.thruster_positions[0, :2]), 0, 0)])
copter_forward_plot = mlab.plot3d(copter_forward[0, :], copter_forward[1, :], copter_forward[2, :], line_width=5, color=(1, 0, 1))
copter_body = np.vstack(([0, 0, 0], hexboi.thruster_positions)).T
copter_body_plot = mlab.points3d(copter_body[0, :], copter_body[1, :], copter_body[2, :], scale_factor=0.15)
copter_body_plot.glyph.scale_mode = 'scale_by_vector'
copter_body_plot.mlab_source.dataset.point_data.scalars = [1, 1, 0.7, 0.7, 0.7, 0.7, 1, 0]  # hack to individually color points

# User interface set-up (hack to override mayavi default keyboard controls)
camera_follow = True
command = [(0, 0, 0), 0]
original_keyPressEvent = fig.scene._vtk_control.keyPressEvent
def keyPressEvent(e):
    global camera_follow, command
    k = str(e.text())
    if k == 'f':
        if camera_follow: camera_follow = False
        else: camera_follow = True
    elif k == 'w':
        command = [np.deg2rad((0, 45, 0)), 0]
    elif k == 's':
        command = [np.deg2rad((0, -45, 0)), 0]
    elif k == 'a':
        command = [np.deg2rad((-45, 0, 0)), 0]
    elif k == 'd':
        command = [np.deg2rad((45, 0, 0)), 0]
    elif k == 'q':
        command = [np.deg2rad((0, 0, 90)), 0]
    elif k == 'e':
        command = [np.deg2rad((0, 0, -90)), 0]
    elif k == '=':
        command = [np.deg2rad((0, 0, 0)), 5]
    elif k == '-':
        command = [np.deg2rad((0, 0, 0)), -5]
    elif k == ' ':
        command = [np.deg2rad((0, 0, 0)), 0]
    else:
        # original_keyPressEvent(e)
        print "Got unknown keypress: ", k
fig.scene._vtk_control.keyPressEvent = keyPressEvent

# Simulation
dt = 0.03
@mlab.animate(delay=int(dt*1000))
def simulate():
    global state, camera_follow
    while True:

        # Apply action and step simulation
        efforts = controller.joy_control(state, command[0], command[1])
        state = hexboi.step_dynamics(state, efforts, dt, wind(state.time))
        if state.pose.lin[2] < -0.1: state.pose.lin[2] = 0

        # Redraw multicopter in scene and move camera accordingly
        R = motion.rotmat_from_quaternion(state.pose.ang)
        copter_body_world = state.pose.lin.reshape(3, 1) + R.dot(copter_body)
        copter_forward_world = state.pose.lin.reshape(3, 1) + R.dot(copter_forward)
        copter_body_plot.mlab_source.set(x=copter_body_world[0, :], y=copter_body_world[1, :], z=copter_body_world[2, :])
        copter_forward_plot.mlab_source.set(x=copter_forward_world[0, :], y=copter_forward_world[1, :], z=copter_forward_world[2, :])
        if camera_follow: mlab.view(focalpoint=state.pose.lin.tolist(), distance=15)
        yield

simulate()
mlab.show()
