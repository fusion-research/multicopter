#!/usr/bin/python
"""
Script for multicopter simulation.
Note: base-SI units are used consistently throughout.

"""
from __future__ import division
import numpy as np; npl = np.linalg
from matplotlib import pyplot
from mpl_toolkits.mplot3d import Axes3D

import multicopter.motion as motion
from multicopter.model import Model
from multicopter.thruster import Thruster

# Thrusters
prop_dia = 0.15
motor_kv = 920
bus_voltage = 0.9 * 14
max_rpm = motor_kv * bus_voltage
thrust_from_effort = lambda rpm: 1e-7 * np.abs(rpm) * rpm
reaction_coeff = 0.1*prop_dia
thruster_positions = [( 0.25,   0  , 0.02),
                      (-0.25,   0  , 0.02),
                      (  0  ,  0.25, 0.02),
                      (  0  , -0.25, 0.02)]
thrusters = {"thr0": Thruster(thruster_positions[0], thrust_from_effort, reaction_coeff, max_rpm),
             "thr1": Thruster(thruster_positions[1], thrust_from_effort, reaction_coeff, max_rpm),
             "thr2": Thruster(thruster_positions[2], thrust_from_effort, -reaction_coeff, max_rpm),
             "thr3": Thruster(thruster_positions[3], thrust_from_effort, -reaction_coeff, max_rpm)}

# Multicopter model
mass = 0.5
inertia = np.diag((5e-3, 5e-3, 9e-3))
drag_lin = np.array([5e-1, 5e-1, 5e-1])
drag_ang = np.array([2e-2, 2e-2, 2e-2])
myboi = Model(thrusters, mass, inertia, drag_lin, drag_ang, gravity=[0, 0, -9.81])

# Temporary controller
def controller(state):
    if state.pose.lin[2] < 2:
        ui = 0.8*max_rpm
        rando = (1.005 - 0.995)*np.random.sample() + 0.995
    else:
        ui = 0
        rando = 1
    # ui = np.sqrt((mass*9.81/4)/1e-7)  # open-loop hover
    return {"thr0": ui, "thr1": ui, "thr2": rando*ui, "thr3": ui}

# Scheduled external disturbance wrench
wind = lambda t: motion.Wrench([0, 0, 0], [0, 0, 0])  # same as None

# Time domain
dt = 0.03
duration = 9
T = np.arange(0, duration, dt)

# Initial condition
P = [[0, 0, 10]]
Q = [[0, 0, 0, 1]]
V = [[0, 0, 0]]
W = [[0, 0, 0]]
states = [motion.State(motion.Pose(P[0], Q[0]), motion.Twist(V[0], W[0]), 0)]
U = []

# Simulation
for i, t in enumerate(T[:-1]):
    efforts = controller(states[i])
    states.append(myboi.step_dynamics(states[i], efforts, dt, wind(t)))
    P.append(states[i+1].pose.lin)
    Q.append(states[i+1].pose.ang)
    V.append(states[i+1].twist.lin)
    W.append(states[i+1].twist.ang)
    U.append([efforts[key] for key in myboi.thruster_keys])

# Main figures
fig = pyplot.figure()
fig.suptitle("Results", fontsize=18)
A_ax = fig.add_subplot(2, 1, 1)
U_ax = fig.add_subplot(2, 1, 2)
P_fig = pyplot.figure()
P_ax = P_fig.add_subplot(111, projection="3d")

# Plot attitude Euler angles
A = np.rad2deg(map(motion.euler_from_quaternion, Q))
A_ax.plot(T, A[:, 0], 'r', label="roll")
A_ax.plot(T, A[:, 1], 'g', label="pitch")
A_ax.plot(T, A[:, 2], 'b', label="yaw")
A_ax.set_xlim([T[0], T[-1]])
A_ax.set_ylabel("Attitude Angle (deg)", fontsize=14)
A_ax.legend(fontsize=12)
A_ax.grid(True)

# Plot thruster efforts
U = np.vstack((np.array(U), [0, 0, 0, 0]))
U_ax.plot(T, U[:, 0], 'r', label=myboi.thruster_keys[0])
U_ax.plot(T, U[:, 1], 'g', label=myboi.thruster_keys[1])
U_ax.plot(T, U[:, 2], 'b', label=myboi.thruster_keys[2])
U_ax.plot(T, U[:, 3], 'm', label=myboi.thruster_keys[3])
U_ax.set_xlim([T[0], T[-1]])
U_ax.set_ylabel("Thruster Effort (RPM)", fontsize=14)
U_ax.legend(fontsize=12)
U_ax.grid(True)
U_ax.set_xlabel("Time (s)", fontsize=14)

# Plot position trajectory
P = np.array(P)
P_ax.set_title("World Position Trajectory", fontsize=18)
P_ax.plot(P[::2, 0], P[::2, 1], P[::2, 2], 'k')
P_ax.scatter(P[0, 0], P[0, 1], P[0, 2], c='k', s=30)
P_ax.scatter(P[-1, 0], P[-1, 1], P[-1, 2], c='g', s=30)
ground_xx, ground_yy = np.meshgrid(np.linspace(np.min(P[:, 0]-5), np.max(P[:, 0]+5), 5),
                                   np.linspace(np.min(P[:, 1]-5), np.max(P[:, 1]+5), 5))
P_ax.plot_surface(ground_xx, ground_yy, np.zeros_like(ground_xx), color='b', alpha=0.2)
P_ax.set_xlabel("x (m)", fontsize=14)
P_ax.set_ylabel("y (m)", fontsize=14)
P_ax.set_zlabel("z (m)", fontsize=14)
P_ax.grid(True)
P_ax.axis("equal")

pyplot.show()
