#!/usr/bin/python
"""
Script for ~iNtErAcTiVe~ realtime multicopter simulation.
See pilot.py for X-Box gamepad installation instructions.
See viz.py for Mayavi graphics installation instructions.

"""
from __future__ import division
import numpy as np; npl = np.linalg
import time

from multicopter.pilot import Pilot
from multicopter.copilot import CoPilot
from multicopter.bois import hexboi as model
from multicopter.viz import Viz
from multicopter import motion

# Graphics / environment config
building_spacing = 3  # m
building_size = (3, 3, 4)  # m
building_layout = np.ones((10, 10))
viz = Viz(model, building_layout, building_size, building_spacing)

# User button-press callbacks
####
# Toggle camera following
def bcb_A(val):
    global cam_follow
    if val:
        if cam_follow: cam_follow = False
        else: cam_follow = True

# Reset state and command
def bcb_B(val):
    global state
    if val:
        state = state0
        copilot.reset(state0)

# Zoom-out camera
def bcb_L(val):
    global cam_dist_rate
    cam_dist_rate = val*20  # m/s

# Zoom-in camera
def bcb_R(val):
    global cam_dist_rate
    cam_dist_rate = -val*20  # m/s

# Change camera elevation
def bcb_DV(val):
    global cam_elev_rate
    cam_elev_rate = val*45  # deg/s

# Change camera azimuth
def bcb_DH(val):
    global cam_azim_rate
    cam_azim_rate = val*45  # deg/s
####

# Initial multicopter condition
t = time.time()
state0 = motion.State(motion.Pose([0, 0, 5], [0, 0, 0, 1]), motion.Twist([0, 0, 0], [0, 0, 0]), t)  # m, s, and rad
state = state0  # warning, not a copy

# User flight control config
kp = [0.0, 0.5, 0.5, 0.5]  # gains [world-up, roll, pitch, yaw]
kd = [7.5, 0.1, 0.1, 0.1]
pilot = Pilot(button_callbacks={"A": bcb_A, "B": bcb_B, "L": bcb_L, "R": bcb_R, "DV": bcb_DV, "DH": bcb_DH})
copilot = CoPilot(model, kp, kd, state0)

# Scheduled external disturbance wrench
wind = lambda t: None

# Initial camera condition
cam_state = {"focalpoint": state0.pose.lin.tolist(), "azimuth": 180, "elevation": 70, "distance": 15}  # m and deg
cam_azim_rate = 0
cam_elev_rate = 0
cam_dist_rate = 0
cam_follow = True

# Simulation loop function
dt = 0.01  # s
@viz.animate(delay=50)  # ms (20 FPS is the best Mayavi can do)
def simulate():
    global state, cam_state, t
    while True:

        # Between each scene render, simulate up to real-time
        while t < time.time():

            # Update user input commands and compute efforts needed to achieve those commands
            command = pilot.get_command()
            efforts = copilot.control(state, command)

            # Step simulation forward given the environment and multicopter thruster efforts
            state = model.compute_next_state(state, efforts, dt, wind(state.time))
            if state.pose.lin[2] < -0.05: state.pose.lin[2] = 0  # basic ground plane
            t += dt

            # Update camera state according to user input
            if cam_follow: cam_state["focalpoint"] = state.pose.lin.tolist()
            cam_state["azimuth"] += dt*cam_azim_rate
            cam_state["elevation"] += dt*cam_elev_rate
            cam_state["distance"] = np.clip(cam_state["distance"] + dt*cam_dist_rate, 5, np.inf)

        # Re-render changed parts of the scene at this real-time instant
        viz.update_multicopter(state, efforts, cam_state)
        yield

# Start'er up
pilot.start_pilot_thread()
simulate()
viz.show()  # blocking

# Be nice
pilot.stop_pilot_thread()
